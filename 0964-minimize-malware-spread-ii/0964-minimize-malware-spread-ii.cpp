class DisjointSet{
public:
    vector<int> parent;
    vector<int> rank;
    
    DisjointSet(int n){
        parent.resize(n);
        rank.resize(n,1);
        for(int i=0;i<n;i++) parent[i]=i;
    }

    int findUltimateParent(int a){
        if(parent[a]==a) return a;
        return parent[a]=findUltimateParent(parent[a]);
    }

    void merge(int a,int b){
        int maxParent_A=findUltimateParent(a);
        int maxParent_B=findUltimateParent(b);

        if(maxParent_A==maxParent_B) return;

        if(rank[maxParent_A]>=rank[maxParent_B]){
            rank[maxParent_A]+=rank[maxParent_B];
            parent[maxParent_B]=maxParent_A;
        }
        else{
            rank[maxParent_B]+=rank[maxParent_A];
            parent[maxParent_A]=maxParent_B;
        }
    }

};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {

        int n=graph.size(),s=initial.size();
        DisjointSet* dsu=new DisjointSet(n);

        vector<int> infected(n,false);
        for(int i=0;i<s;i++) infected[initial[i]]=true;

        for(int i=0;i<n;i++){
            if(infected[i]==true) continue;
            for(int j=0;j<n;j++){
                if(graph[i][j]==1 && i!=j && !infected[j]) dsu->merge(i,j);
            }
        }

        unordered_map<int,unordered_set<int>> mp;
        vector<int> cnt(n,0);

        for(int i=0;i<s;i++){
            int curr=initial[i];
            mp[curr].insert(curr);
            for(int j=0;j<n;j++){
                if(graph[curr][j] && curr!=j && !infected[j]){
                    int p=dsu->findUltimateParent(j);
                    if(!mp[curr].count(p)){
                        mp[curr].insert(p);
                        cnt[p]++;
                    }
                }
            }
        }

        int maxInfections=-1e9,ans=-1e9;

        for(int i=0;i<s;i++){
            int total=0;
            for(auto &j: mp[initial[i]] ){
                if(cnt[j]==1) total+=dsu->rank[j];
            }

            if(total>maxInfections){
                ans=initial[i];
                maxInfections=total;
            }
            else if(total==maxInfections){
                ans=min(ans,initial[i]);
            }
        }
        if(ans==-1e9) return *min_element(initial.begin(), initial.end());

        return ans;
    }
};