class DisjointSet{
public:
    vector<int> parent;
    vector<int> rank;
    
    DisjointSet(int n){
        parent.resize(n);
        rank.resize(n,1);
        for(int i=0;i<n;i++) parent[i]=i;
    }

    int findUltimateParent(int a){
        if(parent[a]==a) return a;
        return parent[a]=findUltimateParent(parent[a]);
    }

    void merge(int a,int b){
        int maxParent_A=findUltimateParent(a);
        int maxParent_B=findUltimateParent(b);

        if(maxParent_A==maxParent_B) return;

        if(rank[maxParent_A]>=rank[maxParent_B]){
            rank[maxParent_A]+=rank[maxParent_B];
            parent[maxParent_B]=maxParent_A;
        }
        else{
            rank[maxParent_B]+=rank[maxParent_A];
            parent[maxParent_A]=maxParent_B;
        }
    }

};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n=graph.size(),s=initial.size();

        DisjointSet* dsu=new DisjointSet(n);

        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                if(graph[i][j]==1 && i!=j) dsu->merge(i,j);
            }
        }

        int ans=1e9,clusterSize=-1e9;

        for(int i=0;i<s;i++){
            int p1=dsu->findUltimateParent(initial[i]);
            bool multipleNodesInCluster=false;
            for(int j=0;j<s;j++){
                int p2=dsu->findUltimateParent(initial[j]);
                if(p1==p2 && i!=j){
                    multipleNodesInCluster=true;
                    break;
                }
            }

            if(!multipleNodesInCluster){
                if(dsu->rank[p1]>clusterSize){
                    ans=initial[i];
                    clusterSize=dsu->rank[p1];
                }
                else if(dsu->rank[p1]==clusterSize) ans=min(ans,initial[i]);
            }
        }
        if(clusterSize==-1e9) for(auto &i: initial) ans=min(i,ans);
        return ans;
    }
};